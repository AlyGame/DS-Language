#ifndef dsmain_H
#define dsmain_H

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdbool.h>
#include <math.h>
#include <time.h>
#include <limits.h>
#include <stdbool.h>

typedef char *string;
typedef int integer;
typedef unsigned int number;
typedef float precise;
typedef char character;
typedef double real;
typedef long int max_int;
typedef long long int max_max_int;
typedef void func;
typedef FILE* file;

#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))

typedef struct{
    int** data;
    int rows;
    int cols;
} Matrix;

Matrix* createMatrix(int rows,int cols)
{
    Matrix* matrix = (Matrix*)malloc(sizeof(matrix));
    if(matrix == NULL)
    {
        return NULL;
    }
    matrix->rows = rows;
    matrix->cols = cols;

    matrix->data = (int **)malloc(rows * sizeof(int*));
    if(matrix->data == NULL)
    {
        free(matrix);
        return NULL;
    }

    for(int i = 0; i<rows;i++)
    {
        matrix->data[i] = (int *)malloc(cols*sizeof(int));
        if(matrix->data[i] == NULL)
        {
            for(int j = 0;j<i;j++)
            {
                free(matrix->data[j]);
            }
            free(matrix->data);
            free(matrix);
            return NULL;
        }
    }
    return matrix;
}

void freeMatrix(Matrix* matrix)
{
    if(matrix != NULL)
    {
        for(int i = 0;i<matrix->rows;i++)
        {
            free(matrix->data[i]);
        }
        free(matrix->data);
        free(matrix);
    }
}

#define loop(init, condition, update, body) \
    do { \
        for (int i = init; i < condition; i += update) { \
            body \
        } \
    } while(0)

#define condition(cond, if_block, else_block) \
    if (cond) { \
        if_block \
    } else { \
        else_block \
    }

#define print(x) _Generic((x), \
    char: print_char, \
    int: print_int, \
    char *: print_string, \
    number : print_number, \
    real: print_real, \
    precise: print_precise, \
    max_int: print_max_int, \
    max_max_int: print_max_max_int, \
    bool: print_boolean \
)(x)

int getInteger(const char *prompt)
{
    int n;
    printf("%s",prompt);
    scanf("%i",&n);
    return n;
}

string getString(char *prompt)
{
    char buffer[1024];
    printf("%s",prompt);
    fgets(buffer,sizeof(buffer),stdin);
    size_t len = strlen(buffer);
    if(len > 0 && buffer[len - 1] == '\n')
    {
        buffer[--len] = '\0';
    }
    string result = (string) malloc(len+1);
    if(result == NULL)
    {
        return NULL;
    }
    strcpy(result,buffer);
    return result;
}


bool getBoolean(char *prompt) {
    bool b;
    printf("%s", prompt);
    scanf("%d", &b);
    return b;
}

number getNumber(char *prompt)
{
    number n;
    printf("%s",prompt);
    scanf("%u",&n);
    return n;
}

real getReal(char *prompt) {
    real n;
    printf("%s", prompt);
    scanf("%lf", &n);
    return n;
}

precise getPrecise(char *prompt) {
    precise n;
    printf("%s", prompt);
    scanf("%f", &n);
    return n;
}

max_int getMaxInt(char *prompt) {
    max_int n;
    printf("%s", prompt);
    scanf("%ld", &n);
    return n;
}

max_max_int getMaxMaxInt(char *prompt)
{
    max_max_int n;
    printf("%s", prompt);
    scanf("%lld", &n);
    return n;
}

void print_char(char c)
{
    printf("%c\n", c);
}

void print_int(int i)
{
    printf("%d\n", i);
}

void print_float(float f)
{
    printf("%f\n", f);
}

void print_string(char *s)
{
    printf("%s\n", s);
}

void print_number(number a)
{
    printf("%d", a);
}

void print_real(real a)
{
    printf("%lf", a);
}

void print_precise(precise a)
{
    printf("%f", a);
}

void print_max_int(max_int a)
{
    printf("%ld", a);
}

void print_max_max_int(max_max_int a)
{
    printf("%lld", a);
}

void print_boolean(bool b) {
    printf("%s\n", b ? "true" : "false");
}

// remained

void getHour(void)
{
    time_t t;
    t = time(NULL);
    struct tm tm;
    tm = *localtime(&t);
    printf("%d",tm.tm_hour);
}

void getDate(void)
{
    time_t t;
    t = time(NULL);
    struct tm tm;
    tm = *localtime(&t);
    printf("%d",tm.tm_mday);
}

void getMonth(void)
{
    time_t t;
    t = time(NULL);
    struct tm tm;
    tm = *localtime(&t);
    printf("%d",tm.tm_mon);
}

void getYear(void)
{
    time_t t;
    t = time(NULL);
    struct tm tm;
    tm = *localtime(&t);
    printf("%d",tm.tm_year);
}

void getSeconds(void)
{
    time_t t;
    t = time(NULL);
    struct tm tm;
    tm = *localtime(&t);
    printf("%d",tm.tm_sec);
}
int compare_strings_asc(const void *a, const void *b) {
    return strcmp(*(const string *)a, *(const string *)b);
}

int compare_strings_desc(const void *a, const void *b) {
    return strcmp(*(const string *)b, *(const string *)a);
}

int compare_integers_asc(const void *a, const void *b) {
    return (*(const integer *)a - *(const integer *)b);
}

int compare_integers_desc(const void *a, const void *b) {
    return (*(const integer *)b - *(const integer *)a);
}

int compare_numbers_asc(const void *a, const void *b) {
    return (*(const number *)a - *(const number *)b);
}

int compare_numbers_desc(const void *a, const void *b) {
    return (*(const number *)b - *(const number *)a);
}

int compare_precise_asc(const void *a, const void *b) {
    return (*(const precise *)a > *(const precise *)b) - (*(const precise *)a < *(const precise *)b);
}

int compare_precise_desc(const void *a, const void *b) {
    return (*(const precise *)b > *(const precise *)a) - (*(const precise *)b < *(const precise *)a);
}

int compare_reals_asc(const void *a, const void *b) {
    return (*(const real *)a > *(const real *)b) - (*(const real *)a < *(const real *)b);
}

int compare_reals_desc(const void *a, const void *b) {
    return (*(const real *)b > *(const real *)a) - (*(const real *)b < *(const real *)a);
}

int compare_characters_asc(const void *a, const void *b) {
    return (*(const character *)a - *(const character *)b);
}

int compare_characters_desc(const void *a, const void *b) {
    return (*(const character *)b - *(const character *)a);
}

int compare_max_ints_asc(const void *a, const void *b) {
    return (*(const max_int *)a > *(const max_int *)b) - (*(const max_int *)a < *(const max_int *)b);
}

int compare_max_ints_desc(const void *a, const void *b) {
    return (*(const max_int *)b > *(const max_int *)a) - (*(const max_int *)b < *(const max_int *)a);
}

int compare_max_max_ints_asc(const void *a, const void *b) {
    return (*(const max_max_int *)a > *(const max_max_int *)b) - (*(const max_max_int *)a < *(const max_max_int *)b);
}

int compare_max_max_ints_desc(const void *a, const void *b) {
    return (*(const max_max_int *)b > *(const max_max_int *)a) - (*(const max_max_int *)b < *(const max_max_int *)a);
}

// Determine the number of elements in a NULL-terminated array of strings
int get_array_length(const string arr[]) {
    int length = 0;
    while (arr[length] != NULL) {
        length++;
    }
    return length;
}

void sort(void *arr, char type, char order) {
    int (*compare)(const void *, const void *);
    switch (type) {
        case 's':
        case 'S':
            compare = (order == 'd' || order == 'D') ? compare_strings_desc : compare_strings_asc;
            break;
        case 'i':
        case 'I':
            compare = (order == 'd' || order == 'D') ? compare_integers_desc : compare_integers_asc;
            break;
        case 'n':
        case 'N':
            compare = (order == 'd' || order == 'D') ? compare_numbers_desc : compare_numbers_asc;
            break;
        case 'p':
        case 'P':
            compare = (order == 'd' || order == 'D') ? compare_precise_desc : compare_precise_asc;
            break;
        case 'd':
        case 'D':
            compare = (order == 'd' || order == 'D') ? compare_reals_desc : compare_reals_asc;
            break;
        case 'c':
        case 'C':
            compare = (order == 'd' || order == 'D') ? compare_characters_desc : compare_characters_asc;
            break;
        case 'm':
        case 'M':
            compare = (order == 'd' || order == 'D') ? compare_max_ints_desc : compare_max_ints_asc;
            break;
        case 'x':
        case 'X':
            compare = (order == 'd' || order == 'D') ? compare_max_max_ints_desc : compare_max_max_ints_asc;
            break;
        default:
            printf("Invalid data type argument.\n");
            return;
    }

    int num_elems = 0;
    switch (type) {
        case 's':
        case 'S': {
            string *str_arr = (string *)arr;
            num_elems = get_array_length(str_arr);
            qsort(str_arr, num_elems, sizeof(string), compare);
            for (int i = 0; i < num_elems; i++) {
                printf("%s\n", str_arr[i]);
            }
            break;
        }
        case 'i':
        case 'I': {
            integer *int_arr = (integer *)arr;
            while (int_arr[num_elems] != 0) {
                num_elems++;
            }
            qsort(int_arr, num_elems, sizeof(integer), compare);
            for (int i = 0; i < num_elems; i++) {
                printf("%d\n", int_arr[i]);
            }
            break;
        }
        case 'n':
        case 'N': {
            number *num_arr = (number *)arr;
            while (num_arr[num_elems] != 0) {
                num_elems++;
            }
            qsort(num_arr, num_elems, sizeof(number), compare);
            for (int i = 0; i < num_elems; i++) {
                printf("%u\n", num_arr[i]);
            }
            break;
        }
        case 'p':
        case 'P': {
            precise *precise_arr = (precise *)arr;
            while (precise_arr[num_elems] != 0) {
                num_elems++;
            }
            qsort(precise_arr, num_elems, sizeof(precise), compare);
            for (int i = 0; i < num_elems; i++) {
                printf("%f\n", precise_arr[i]);
            }
            break;
        }
        case 'd':
        case 'D': {
            real *real_arr = (real *)arr;
            while (real_arr[num_elems] != 0) {
                num_elems++;
            }
            qsort(real_arr, num_elems, sizeof(real), compare);
            for (int i = 0; i < num_elems; i++) {
                printf("%lf\n", real_arr[i]);
            }
            break;
        }
        case 'c':
        case 'C': {
            character *char_arr = (character *)arr;
            while (char_arr[num_elems] != '\0') {
                num_elems++;
            }
            qsort(char_arr, num_elems, sizeof(character), compare);
            for (int i = 0; i < num_elems; i++) {
                printf("%c\n", char_arr[i]);
            }
            break;
        }
        case 'm':
        case 'M': {
            max_int *max_int_arr = (max_int *)arr;
            while (max_int_arr[num_elems] != 0) {
                num_elems++;
            }
            qsort(max_int_arr, num_elems, sizeof(max_int), compare);
            for (int i = 0; i < num_elems; i++) {
                printf("%ld\n", max_int_arr[i]);
            }
            break;
        }
        case 'x':
        case 'X': {
            max_max_int *max_max_int_arr = (max_max_int *)arr;
            while (max_max_int_arr[num_elems] != 0) {
                num_elems++;
            }
            qsort(max_max_int_arr, num_elems, sizeof(max_max_int), compare);
            for (int i = 0; i < num_elems; i++) {
                printf("%lld\n", max_max_int_arr[i]);
            }
            break;
        }
    }
}

unsigned long long factorial(int n)
{
    if(n<0)
    {
        return 0;
    }
    if(n==0||n == 1)
    {
        return 1;
    }
    return n * factorial(n-1);
}

double power(double base, int exponent)
{
    if(exponent<0)
    {
        return 1.0 / power(base, -exponent);
    }
    else if(exponent == 0)
    {
        return 1.0;
    }
    else
    {
        return base * power(base, exponent-1);
    }
}


int gcd(int a,int b)
{
    if(b == 0)
    {
        return a;
    }
    return gcd(b, a%b);
}


int lcm(int a, int b)
{
    return (a * b) / gcd(a,b);
}

// if(isPrime(number,trueSting, falseString))
// { print(trueString); } else { print(falseString) }

bool isPrime(int n, const char* trueString, const char* falseString)
{
    if (n <= 1)
    {
        printf("%s", falseString);
        return false;
    }
    else if (n <= 3)
    {
        printf("%s", trueString);
        return true;
    }
    else if (n % 2 == 0 || n % 3 == 0)
    {
        printf("%s", falseString);
        return false;
    }
    for (int i = 5; i * i <= n; i += 6)
    {
        if (n % i == 0 || n % (i + 2) == 0)
        {
            printf("%s", falseString);
            return false;
        }
    }
    return true;
}

// LUCRUL CU FISIERE  inloc de FILE* se va scrie file

FILE* open(const char* fileName)
{
    FILE* file = fopen(fileName,"a+");
    return file;
}

void write(FILE* file, const char* text)
{
    fprintf(file,"%s\n",text);
}

void read(FILE* file)
{
    char line[256];
    rewind(file);
    while(fgets (line,sizeof(line), file))
    {
        printf("%s",line);
    }
}

void close(FILE* file)
{
    fclose(file);
}

void initGenerator()
{
    srand(time(NULL));
}

int Srandom(integer min, integer max)
{
    initGenerator();
    return min +rand() %  ( max - min + 1);
}

char* generatePassword(int lenght)
{
    const char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+";
    char* password = (char *)malloc((lenght+1)*sizeof(char));

    if(password == NULL)
    {
        printf("Memory allocation has failed.");
        exit(1);
    } 

    srand(time(NULL));
    for(int i = 0;i<lenght;i++)
    {
        int index = rand() % (sizeof(charset) - 1);
        password[i] = charset[index];
    }
    password[lenght] = '\0';
    return password;
    free(password);
}


int minimum(int a, int b, int c)
{
    if(a<b&&a<c) return a;
    if(b<a&&b<c) return b;
    return c;
}

int levenshteinDistance(char *str1, char *str2) {
    int len1 = strlen(str1);
    int len2 = strlen(str2);
    
    // Alocare dinamică a matricei
    int** matrix = (int**)malloc((len1 + 1) * sizeof(int*));
    for (int i = 0; i <= len1; i++) {
        matrix[i] = (int*)malloc((len2 + 1) * sizeof(int));
    }

    for (int i = 0; i <= len1; i++) {
        for (int j = 0; j <= len2; j++) {
            if (i == 0) {
                matrix[i][j] = j;
            } else if (j == 0) {
                matrix[i][j] = i;
            } else if (str1[i - 1] == str2[j - 1]) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                matrix[i][j] = 1 + minimum(matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]);
            }
        }
    }

    int distance = matrix[len1][len2];

    // Eliberarea memoriei alocate pentru matrice
    for (int i = 0; i <= len1; i++) {
        free(matrix[i]);
    }
    free(matrix);

    return distance;
}


// AI FUNCTIONS !!!!!

// structura pentru setul de date
 
typedef struct {
    double** features; // matrice de caracterisitici ( exemple: x atribute )
    double* labels; // vector de etichete
    int num_examples; // numarul de exemple din setul de date
    int num_attributes; // numerul de atribute per exemplu
} DataSet;

// structura pentru modelul de regresie liniara

typedef struct{
    double* weights; // vectori de ponderi ( coefficienti )
    int num_attributes; // numarul de atribute
} Model;
DataSet* createDataset(int num_examples, int num_attributes) {
    DataSet* dataset = (DataSet*)malloc(sizeof(DataSet));
    if (dataset == NULL) {
        fprintf(stderr, "Error: Error at memory allocation for the DataSet\n");
        exit(1);
    }
    dataset->num_examples = num_examples;
    dataset->num_attributes = num_attributes;

    dataset->features = (double **)malloc(num_examples * sizeof(double*));
    if (dataset->features == NULL) {
        fprintf(stderr, "Error: Error at memory allocation for the features\n");
        free(dataset);
        exit(1);
    }

    for (int i = 0; i < num_examples; i++) {
        dataset->features[i] = (double*)malloc(num_attributes * sizeof(double));
        if (dataset->features[i] == NULL) {
            fprintf(stderr, "Error: Error at memory allocation for features[%d]\n", i);
            // Eliberează memoria alocată înainte
            for (int j = 0; j < i; j++) {
                free(dataset->features[j]);
            }
            free(dataset->features);
            free(dataset);
            exit(1);
        }
    }
    dataset->labels = (double*)malloc(num_examples * sizeof(double));
    if (dataset->labels == NULL) {
        fprintf(stderr, "Error: Error at the memory allocation for labels\n");
        for (int i = 0; i < num_examples; i++) {
            free(dataset->features[i]);
        }
        free(dataset->features);
        free(dataset);
        exit(1);
    }
    return dataset;
}
void freeDataset(DataSet* dataset)
{
    if(dataset == NULL)
    {
        return;
    }
    for(int i = 0; i < dataset->num_examples; i++)
    {
        free(dataset->features[i]);
    }
    free(dataset->features);
    free(dataset->labels);
    free(dataset);
}

void trainModel(Model* model, DataSet* dataset, int num_epochs, double learning_rate)
{
    int num_examples = dataset->num_examples;
    int num_attributes = dataset->num_attributes;

    for(int epoch = 0; epoch < num_epochs; epoch++)
    {
        for(int example = 0; example < num_examples; example++)
        {
            // calculeaza predictia
            double prediction = 0.0;
            for(int attribute = 0; attribute < num_attributes; attribute++)
            {
                prediction += model->weights[attribute] * dataset->features[example][attribute];
            }
            // calculeaza eroarea
            double err = prediction - dataset->labels[example];

            for(int attribute = 0; attribute < num_attributes; attribute++)
            {
                model->weights[attribute] -= learning_rate * err * dataset->features[example][attribute];
            }
        }
    }
}

double evaluateModel(Model* model,DataSet* dataset)
{
    int num_examples = dataset->num_examples;
    int num_attributes = dataset->num_attributes;
    double mean_squared_error = 0.0;

    for(int example = 0; example < num_examples; example++)
    {
        double prediction = 0.0;
        for(int attribute = 0; attribute < num_attributes; attribute++)
        {
            prediction += model->weights[attribute] * dataset->features[example][attribute];
        }
        double err = prediction - dataset->labels[example];
        mean_squared_error += err * err;
    }
    return mean_squared_error / num_examples;
}

// Funcție pentru a face o predicție cu modelul antrenat
double predict(Model* model, double* features) {
    int num_attributes = model->num_attributes;
    double prediction = 0.0;

    for (int attribute = 0; attribute < num_attributes; attribute++) {
        prediction += model->weights[attribute] * features[attribute];
    }

    return prediction;
}

// functie pentru salvarea modelului

void saveModel(Model* model, const char* filename) {
    FILE* file = fopen(filename, "wb");
    if (file == NULL) {
        fprintf(stderr, "Eroare la deschiderea fișierului pentru salvare\n");
        exit(1);
    }

    fwrite(&(model->num_attributes), sizeof(int), 1, file);
    fwrite(model->weights, sizeof(double), model->num_attributes, file);

    fclose(file);
}

// Funcție pentru a încărca un model dintr-un fișier
Model* loadModel(const char* filename) {
    FILE* file = fopen(filename, "rb");
    if (file == NULL) {
        fprintf(stderr, "Eroare la deschiderea fișierului pentru încărcare\n");
        exit(1);
    }

    Model* model = (Model*)malloc(sizeof(Model));
    if (model == NULL) {
        fprintf(stderr, "Eroare la alocarea memoriei pentru model\n");
        fclose(file);
        exit(1);
    }

    fread(&(model->num_attributes), sizeof(int), 1, file);
    model->weights = (double*)malloc(model->num_attributes * sizeof(double));
    if (model->weights == NULL) {
        fprintf(stderr, "Eroare la alocarea memoriei pentru ponderi\n");
        free(model);
        fclose(file);
        exit(1);
    }

    fread(model->weights, sizeof(double), model->num_attributes, file);

    fclose(file);
    return model;
}

void* allocateMemory(size_t size)
{
    void* ptr = malloc(size);
    if(ptr == NULL)
    {
        return NULL;
    }
    return ptr;
}

int binarySearch(int arr[],int n, int target)
{
    int left = 0;
    int right = n -1 ;
    while(left<-right)
    {
        int mid = (left + right ) / 2;
        if(arr[mid] == target)
        {
            return mid;
        }
        else if(arr[mid] < target)
        {
            left = mid + 1;
        }
        else
        {
            right = mid -1;
        }
        
    }
    return -1;
}

char* encryptText(char *text,int key)
{
    int len = strlen(text);
    char* encryped_text = (char *)malloc(len+1);
    for(int i = 0; i < len; i++)
    {
        encryped_text[i] = text[i] + key;
    }
    encryped_text[len] = '\0';
    return encryped_text;
}

char* decryptText(char* text, int key)
{
    int len = strlen(text);
    char* decrypted_text = (char *)malloc(len+1);
    for(int i = 0;i < len; i++)
    {
        decrypted_text[i] = text[i] - key;
    }
    decrypted_text[len] = '\0';
    return decrypted_text;
}

int getLength(char* text)
{
    int len = strlen(text);
    return len;
}

int squareRoot(int number)
{
    int i = 1;
    while(i*i <= number)
    {
        i++;
    }
    return i-1;
}
#endif
